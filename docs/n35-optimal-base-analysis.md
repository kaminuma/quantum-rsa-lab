---
title: "N=35 因数分解における最適基数選択: a=6, 周期 r=2 の理論的解析"
authors: quantum-crypto-lab
date: 2026-01-31
---

# N=35 因数分解における最適基数選択の理論的解析

## Abstract

本稿では、Shor型の order-finding（位相推定）を compiled/encoded した設定で N=35 の因数分解を扱い、基数 a=6 を選択することで周期 r=2 という最小周期が得られ、大幅に簡素化された量子回路が構成可能であることを示す。ここでの「3量子ビット・2Qゲート2個」は、2ビット逆QFTのSWAPを省略し、測定後にビット順を古典的に補正する前提である。本稿における「最適」とは、compiled/encoded 実装において量子資源（量子ビット数・2量子ビットゲート数）を最小化する基数選択を指す。数論的な厳密な証明を与え、既存研究との比較、および本手法に対する潜在的批判への回答を提示する。

---

## 1. 導入

### 1.1 背景

Shorのアルゴリズム [Shor, 1994] は、整数 N の因数分解を多項式時間で解く量子アルゴリズムである。アルゴリズムの中核は、関数 f(x) = a^x mod N の周期 r を量子位相推定（QPE）により発見することにある。

N=35 の因数分解は、複数の研究グループにより実機での実行が試みられてきた。代表的な公開報告は以下の通りである：

- **Amico et al. (2019)**: ibmqx5 上で compiled Shor を N=15/21/35 に適用（半古典QFT）。N=35 の詳細パラメータや評価指標は原論文に記載。[6]
- **Bagourd et al. (2025)**: N=35 で a=4 (r=6) と a=8 (r=4) を比較し、位相ヒット率と一様ベースラインの差を報告。[4]

本稿では、**a=6 を選択することで r=2 という最小周期が得られる**ことを示し、これにより3量子ビット・2Qゲート2個という極めて簡素な回路構成が可能であることを論じる。

### 1.2 本研究の貢献

1. **数論的証明**: N=35 において ord₃₅(6) = 2 であることの厳密な証明
2. **回路最適化**: 本稿の a=8 実装（5量子ビット・2Qゲート8個）と比較して、量子ビット数 40%削減、2Qゲート数 75%削減
3. **批判への回答**: 「事前知識の使用」批判に対する理論的反論

---

## 2. 数論的基礎

### 2.1 準備

**定義 2.1 (乗法群)**
N を正整数とするとき、N と互いに素な {1, 2, ..., N-1} の元全体は乗法に関して群をなす。これを Z_N^* と記す。

**定義 2.2 (位数)**
a ∈ Z_N^* に対し、a^r ≡ 1 (mod N) を満たす最小の正整数 r を a の N を法とする位数といい、ord_N(a) と記す。

**定理 2.1 (オイラーの定理)**
gcd(a, N) = 1 ならば a^φ(N) ≡ 1 (mod N)

ここで φ(N) はオイラーのトーシェント関数である。

### 2.2 N=35 の群構造

**命題 2.1**
N = 35 = 5 × 7 に対し、以下が成り立つ：

(i) φ(35) = φ(5) × φ(7) = 4 × 6 = 24

(ii) Z₃₅^* ≅ Z₅^* × Z₇^* ≅ Z₄ × Z₆ （中国剰余定理による）

**証明**
(i) φ(p) = p - 1 （p は素数）より、φ(5) = 4, φ(7) = 6。
   φ は乗法的関数であるから、φ(35) = φ(5)φ(7) = 24。

(ii) gcd(5, 7) = 1 より、中国剰余定理から Z₃₅ ≅ Z₅ × Z₇。
   この同型は乗法群にも制限され、Z₃₅^* ≅ Z₅^* × Z₇^*。
   Z₅^* は位数 4 の巡回群、Z₇^* は位数 6 の巡回群である。 □

### 2.3 Z₃₅^* の元の位数分布

**命題 2.2**
Z₃₅^* の24個の元は、以下の位数分布を持つ：

| 位数 r | 元の個数 | 元の例 |
|--------|----------|--------|
| 1 | 1 | {1} |
| 2 | 3 | {6, 29, 34} |
| 3 | 2 | {11, 16} |
| 4 | 4 | {8, 13, 22, 27} |
| 6 | 6 | {4, 9, 19, 24, 26, 31} |
| 12 | 8 | {2, 3, 12, 17, 18, 23, 32, 33} |

**証明**
各 a ∈ Z₃₅^* に対し、中国剰余定理により a ↔ (a mod 5, a mod 7)。
位数は ord₃₅(a) = lcm(ord₅(a mod 5), ord₇(a mod 7)) で計算される。

例として a = 6 の場合：
- 6 mod 5 = 1, ord₅(1) = 1
- 6 mod 7 = 6, ord₇(6) = 2 （∵ 6² = 36 ≡ 1 mod 7）
- ∴ ord₃₅(6) = lcm(1, 2) = 2 □

---

## 3. a=6 の最適性の証明

### 3.1 主定理

**定理 3.1 (a=6 の位数)**
ord₃₅(6) = 2

**証明**
直接計算により：
- 6¹ = 6 ≢ 1 (mod 35)
- 6² = 36 = 35 + 1 ≡ 1 (mod 35)

したがって ord₃₅(6) = 2。 □

**定理 3.2 (古典後処理の確実性)**
N = 35, a = 6, r = 2 が正しく得られたとき、Shorの古典後処理は必ず非自明な因数を返す（理想条件）。

**証明**
以下では量子部分で正しい周期 r=2 が得られたことを前提に、古典後処理が必ず成功することを示す。
Shor の古典後処理が成功するための条件を順に検証する：

**条件1**: gcd(a, N) = 1
gcd(6, 35) = 1 ✓

**条件2**: r が偶数
r = 2 は偶数 ✓

**条件3**: a^(r/2) ≢ -1 (mod N)
6^(2/2) = 6^1 = 6
-1 mod 35 = 34
6 ≠ 34 ✓

**条件4**: gcd(a^(r/2) - 1, N) または gcd(a^(r/2) + 1, N) が非自明
- gcd(6 - 1, 35) = gcd(5, 35) = 5 ∈ {2, ..., 34}
- gcd(6 + 1, 35) = gcd(7, 35) = 7 ∈ {2, ..., 34}

4条件全てを満たすため、order-finding により r=2 が得られた場合の Shor の古典後処理は N = 35 を 5 × 7 に因数分解する。（本稿の量子回路はこの order-finding を compiled/encoded した実装である。） □

### 3.2 位数 r=2 の基数の完全列挙

**命題 3.1**
Z₃₅^* において位数 2 を持つ元は {6, 29, 34} の3個のみである。

**命題 3.2**
位数 2 の元のうち、Shorのアルゴリズムで使用可能なのは a = 6 と a = 29 のみである。

**証明**
a = 34 の場合：
34^(2/2) = 34^1 = 34 ≡ -1 (mod 35)

これは条件3に違反するため、a = 34 は使用不可。

a = 6 および a = 29 は定理3.2と同様の議論により使用可能。 □

---

## 4. 量子回路の構成

### 4.1 状態空間の圧縮

**2Qゲート数の定義**:
本稿ではエンタングリング（2量子ビット）ゲートの個数のみを数え、1量子ビットゲートと測定はカウントしない。
また、逆QFTのSWAPは省略し、測定後に古典的なビット反転で補正する前提で数える。
本稿の2Qゲート数は、回路記述上の2量子ビット演算（CNOT, controlled-phase 等）を抽象ゲートとして数え、ハードウェア依存の分解（例：CP→CX+1Q）後のカウントは扱わない。ネイティブゲートセット（CZ, iSWAP 等）への分解後は2Qゲート数が増加しうる。

周期 r = 2 より、f(x) = 6^x mod 35 が取りうる値は：
- 6^0 mod 35 = 1
- 6^1 mod 35 = 6

したがって、**2状態のみ**を表現すればよく、**1量子ビット**で十分である。

本回路は a=6 による乗法作用 U: x ↦ 6x mod 35 が {1,6} の2点軌道上で閉じることを利用する。U は span{|1⟩,|6⟩} を不変部分空間として持つため、本稿ではこの部分空間上の等価表現として1量子ビット符号化を採用する（compiled order-finding）。したがって一般の modular exponentiation 回路を実装するものではない。この2次元不変部分空間上で U は固有値 ±1 を持ち、対応する固有位相は {0, 1/2} であるため、t=2 の QPE で {00, 10} が理想的に支配的となる。

**状態マッピング**:
```
|1⟩ ↔ |0⟩
|6⟩ ↔ |1⟩
```

作業レジスタは写像 |1⟩↔|0⟩ により、単位元 |1⟩ に対応する計算基底 |0⟩ へ初期化されている。

### 4.2 制御ユニタリ演算子

**U^(2^k) の構成**:

**U^1 (k=0)**:
状態遷移: |1⟩ → |6⟩, |6⟩ → |1⟩
量子回路: |0⟩ ↔ |1⟩ = X ゲート
制御付き: Controlled-X = CNOT

**U^2 (k=1)**:
6^2 ≡ 1 (mod 35) より、U^2 = Identity
制御付き: 何も行わない

**U^(2^k) for k ≥ 1**:
周期 r = 2 より、U^(2^k) = (U^2)^(2^(k-1)) = I^(2^(k-1)) = I

### 4.3 完全な回路構成

以下では2ビット逆QFTを抽象ゲート列として扱い、逆QFT内の controlled-phase（CP）を2Qゲート1個として数える。なお、トランスパイル後に CP が CX + 1Q へ分解される場合でも、本稿では論理回路レベルの2Q数（CP を1個）として比較する。

q0 は |0⟩（= encoded |1⟩）から開始する。

```
量子ビット構成:
- 制御レジスタ: 2量子ビット (c0, c1)
- 作業レジスタ: 1量子ビット (q0)
- 合計: 3量子ビット

回路:
     ┌───┐                ┌─────────┐
c0: ─┤ H ├──●─────────────┤         ├─── M
     └───┘  │             │  QFT†   │
     ┌───┐  │             │(CP含む) │
c1: ─┤ H ├──┼─────────────┤         ├─── M
     └───┘  │             └─────────┘
            │
q0: ────────⊕─────────────────────────────
         (CNOT: c0→q0)

2Qゲートは「CNOT（制御U^1、c0→q0）」+「CP（逆QFT内）」の計2個（SWAP省略）
```

※ 図中の CP(−π/2) は 2ビットQFT† の等価表現の一例であり、実装（QiskitのQFT†など）では制御/ターゲットや符号が異なる表記になり得る。本稿では QFT† は Appendix B の実装を正とする。

※ r=2 のため高位制御ビット (c1) に対応する制御Uは恒等となり、作業レジスタへの作用は省略できる。

**ビット順の補正**:
`do_swaps=False` のため測定ビット列は通常の QPE 出力と逆順になる。以降、測定結果 c1 c0 を古典的に反転して c0 c1 として位相推定値に対応付ける。以降、測定ビット列はビット順補正後の順序（c0 c1）で表記する。

**期待される測定分布（理想）**:
位相推定では φ = s/r（s ∈ {0,1,...,r−1}）を推定する。r=2 より φ ∈ {0, 1/2}。t=2 ビット QPE の測定結果は m ≈ 2^t φ ∈ {0, 2} となり、ビット順補正後の測定ビット列は {00, 10} が支配的となる。

※ 2ビット逆QFTは通常SWAPを含む実装が多い。ここではSWAPを省略し、測定後にビット順を古典的に反転して補正する前提で 2Qゲート数を数える。

### 4.4 回路メトリクスの比較

| 項目 | N=21 (a=4, r=3) [3] | N=35 (a=6, r=2) 本稿 |
|------|---------------------|----------------------|
| 制御量子ビット | 3 | **2** |
| 作業量子ビット | 2 | **1** |
| **合計量子ビット** | 5 | **3** |
| 2Qゲート数 | 25 | **2** |
| 回路深度 | 35 | **~7** |

※ N=21 の値は Skosana & Tame (2021) [3] の報告値。N=35 (a=4, r=6) は周期が大きく回路が複雑になるため、本表では省略した。

※ 回路深度 ~7 は概算（order-of-magnitude）である。2ビット逆QFT部分の深度は実装・トランスパイルに依存するため、本稿では精密な深度最適化は扱わない。

---

## 5. 既存研究との比較

### 5.1 Bagourd et al. (2025) との比較

Bagourd らは "Practical Challenges in Executing Shor's Algorithm on Existing Quantum Platforms" [4] において、N=35 で a=4 (r=6) と a=8 (r=4) を比較し、位相ヒット率と一様ベースラインの差を報告している（t=10、shots=4096）。本稿では論文の結論のみを参照し、数値詳細は原論文に委ねる。

**重要な点**: 同論文には **a=6 (r=2)** の実験結果は報告されていない。

同論文でも、基数選択が周期 r と回路深度を決め、"friendly" な基数ほど回路が浅くなる点が指摘されている。[4]

### 5.2 Skosana & Tame (2021) との比較

N=21 の最適化実装 [Scientific Reports 11, 16599 (2021)] との比較：

| 項目 | N=21 | N=35 (本手法) |
|------|------|---------------|
| 対象数 | 21 = 3 × 7 | 35 = 5 × 7 |
| 基数 | a = 4 | a = 6 |
| 周期 | r = 3 | r = 2 |
| 状態数 | 3 | 2 |
| 量子ビット | 5 | **3** |

**注目すべき点**: より大きな数 (35 > 21) に対し、より少ない量子ビット (3 < 5) で因数分解が可能。

---

## 6. 潜在的批判への回答

### 6.1 「事前知識の使用」批判

**批判**: Smolin, Smith & Vargo (2013) の "Oversimplifying Quantum Factoring" [Nature 499, 163-165] は、「答えを知った状態で回路をコンパイルすること」を批判している。

**回答**:

1. **基数選択はアルゴリズムの一部である**
   - Shorのアルゴリズムは「ランダムに基数 a を選ぶ」ステップを含む
   - 本稿では Shor の標準手順に従い、a は {2,3,…,N−1} から一様にサンプルし、gcd(a,N)=1 を満たすまでリサンプリングする。したがって a の分布は Z₃₅^* \\ {1}（サイズ 23）上で条件付き一様である
   - この条件の下で a=6 が選ばれる確率は 1/23 ≈ 4.3%
   - これは答えの事前知識ではなく、アルゴリズムの確率的性質の一部
   - なお a=1 は常に r=1 を与えて自明であるため除外し、Z₃₅^* \\ {1}（サイズ23）上で議論する

2. **数論的性質は容易に検証できる**
   - ord₃₅(6) = 2 は、N=35 が与えられれば因数分解を用いずとも 6² = 36 ≡ 1 (mod 35) の直接計算で容易に検証できる
   - これは因数の事前知識を必要としない

3. **論点の分離（a の選択と compiled/encoded 圧縮）**
   - a=6 の選択それ自体は Shor の標準手順（ランダムな a の選択＋gcd フィルタ）の範囲にあり、因数の事前知識を前提としない
   - 一方で、本稿の 2状態への圧縮（エンコード設計）は、U: x ↦ a^x mod N が張る不変部分空間（軌道）を事前に同定して回路を compiled する手法であり、一般の black-box な modular exponentiation をそのまま実装する設定とは前提が異なる
   - したがって本稿はスケーリング優位性の主張ではなく、**「基数選択が compiled 回路の量子資源を劇的に変える」**という設計論（hardware-aware / co-design 的観点）の整理と、その整合的な理論付けを目的とする

4. **古典探索の非スケール性**
   - r=2 を狙う基数探索は小さな N では古典的に容易だが、一般の N に対しては多項式時間を保証しない
   - したがって本稿はスケーリング優位性を主張しない

### 6.2 「Cherry-picking」批判

**批判**: 最も有利な基数を選んでいるのではないか。

**回答**:

1. **透明性の確保**
   - ここでの「成功/失敗」は Shor の古典後処理が非自明因数を返すか（r が偶数かつ a^(r/2) ≢ −1 (mod N)）により定義する
   - 本稿では Z₃₅^* の全24元の位数を列挙した
   - 失敗集合は (i) r が奇数の {11,16}、または (ii) a^(r/2) ≡ -1 (mod N) の {19,24,34} の計5個である
   - よって成功集合のサイズは 23 − 5 = 18 であり、成功確率は 18/23 ≈ 78.3% である
   - r=2 かつ非自明因数が得られる確率は 2/23 ≈ 8.7%（a=6, 29）である

2. **最適基数選択は正当な最適化である**
   - 量子回路の最適化において、数論的性質の活用は標準的手法
   - N=21 (a=4, r=3) の選択も同様の最適化の結果
   - 「最適な基数を選ぶ」ことと「答えを知って回路をコンパイルする」ことは異なる

3. **比較実験の提案**
   - 複数の基数 (a=4, 6, 8) での実機実験を行い、成功率を比較することで
   - 「最適基数選択」の有効性を定量的に示すことができる

### 6.3 実用性への批判

**批判**: N=35 の因数分解は実用的ではない。

**回答**:

1. これは proof-of-concept 実験である
2. 目的は「基数選択が必要な量子リソースを劇的に変える」ことの実証
3. 本稿の最適化（軌道 {1,6} への圧縮）は N=35, a=6 の小位数構造に依存する compiled 手法であり、一般の Shor のスケーリング改善を主張するものではない

---

## 7. 結論

本稿では、Shor型 order-finding を compiled/encoded した設定で N=35 の因数分解を扱い、基数 a=6 により周期 r=2 が得られる場合に、わずか3量子ビット・2Qゲート2個の回路で位相推定を実装できることを示した。

主な結果：

1. **数論的証明**: ord₃₅(6) = 2 の厳密な証明を与えた
2. **回路最適化**: a=8実装と比較して量子ビット数 40%削減、2Qゲート数 75%削減
3. **新規性**: a=6 (r=2) を主要ケースとして系統的に扱い、回路メトリクスと整合的に比較した報告は、少なくとも我々の調査範囲（Amico et al. 2019, Bagourd et al. 2025 等）では見当たらなかった（to the best of our knowledge）
4. **批判への対応**: 「事前知識」「cherry-picking」批判への理論的反論を提示

今後の課題として、実機（Rigetti Ankaa-3 等）での実験と、複数基数での比較実験が挙げられる。

---

## References

[1] P. W. Shor, "Algorithms for quantum computation: discrete logarithms and factoring," Proceedings 35th Annual Symposium on Foundations of Computer Science, 1994, pp. 124-134.

[2] J. A. Smolin, G. Smith, and A. Vargo, "Oversimplifying quantum factoring," Nature, vol. 499, no. 7457, pp. 163-165, 2013.

[3] U. Skosana and M. Tame, "Demonstration of Shor's factoring algorithm for N = 21 on IBM quantum processors," Scientific Reports, vol. 11, no. 1, p. 16599, 2021.

[4] P. Bagourd et al., "Practical Challenges in Executing Shor's Algorithm on Existing Quantum Platforms," arXiv:2512.15330, 2025.

[5] S. Beauregard, "Circuit for Shor's algorithm using 2n+3 qubits," Quantum Information & Computation, vol. 3, no. 2, pp. 175-185, 2003.

[6] E. Amico et al., "Experimental study of Shor’s factoring algorithm using the IBM Q quantum computer," Phys. Rev. A 100, 012305 (2019).

---

## Appendix A: 計算コード

```python
from math import gcd

N = 35
a = 6

# 位数の計算
r = 1
while pow(a, r, N) != 1:
    r += 1
print(f"ord_{N}({a}) = {r}")  # 出力: ord_35(6) = 2

# Shor成功条件の検証
assert gcd(a, N) == 1, "条件1違反"
assert r % 2 == 0, "条件2違反"
assert pow(a, r // 2, N) != N - 1, "条件3違反"

p = gcd(pow(a, r // 2, N) - 1, N)
q = gcd(pow(a, r // 2, N) + 1, N)
print(f"{N} = {p} × {q}")  # 出力: 35 = 5 × 7
```

## Appendix B: 量子回路実装

```python
from qiskit import QuantumCircuit
from qiskit.circuit.library import QFT

def build_n35_optimal_circuit():
    """N=35, a=6, r=2 の最適化回路"""
    n_count = 2  # 制御量子ビット
    n_work = 1   # 作業量子ビット

    qc = QuantumCircuit(n_count + n_work, n_count)

    # q0 (work register) starts in |0>, which encodes the multiplicative identity |1>
    # under the mapping |1>↔|0>, |6>↔|1>.

    # 制御レジスタを |+⟩ に初期化
    qc.h(0)
    qc.h(1)

    # 制御付き U^1 = CNOT (c0 → q0)
    qc.cx(0, n_count)

    # 制御付き U^2 = Identity (何もしない)

    # 逆QFT
    qc.append(QFT(n_count, inverse=True, do_swaps=False), range(n_count))

    # 測定
    qc.measure(range(n_count), range(n_count))

    return qc
```

## Appendix C: Z₃₅^* の完全な位数テーブル

| a | a mod 5 | a mod 7 | ord₅ | ord₇ | ord₃₅ |
|---|---------|---------|------|------|-------|
| 1 | 1 | 1 | 1 | 1 | 1 |
| 2 | 2 | 2 | 4 | 3 | 12 |
| 3 | 3 | 3 | 4 | 6 | 12 |
| 4 | 4 | 4 | 2 | 3 | 6 |
| 6 | 1 | 6 | 1 | 2 | 2 |
| 8 | 3 | 1 | 4 | 1 | 4 |
| 9 | 4 | 2 | 2 | 3 | 6 |
| 11 | 1 | 4 | 1 | 3 | 3 |
| 12 | 2 | 5 | 4 | 6 | 12 |
| 13 | 3 | 6 | 4 | 2 | 4 |
| 16 | 1 | 2 | 1 | 3 | 3 |
| 17 | 2 | 3 | 4 | 6 | 12 |
| 18 | 3 | 4 | 4 | 3 | 12 |
| 19 | 4 | 5 | 2 | 6 | 6 |
| 22 | 2 | 1 | 4 | 1 | 4 |
| 23 | 3 | 2 | 4 | 3 | 12 |
| 24 | 4 | 3 | 2 | 6 | 6 |
| 26 | 1 | 5 | 1 | 6 | 6 |
| 27 | 2 | 6 | 4 | 2 | 4 |
| 29 | 4 | 1 | 2 | 1 | 2 |
| 31 | 1 | 3 | 1 | 6 | 6 |
| 32 | 2 | 4 | 4 | 3 | 12 |
| 33 | 3 | 5 | 4 | 6 | 12 |
| 34 | 4 | 6 | 2 | 2 | 2 |

---

*Last Updated: 2026-01-31*
